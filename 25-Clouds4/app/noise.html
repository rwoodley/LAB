<!doctype html>
<html lang="en">
    <head>
        <title>Clouds</title>
        <meta charset="utf-8">
</head>
 
<body>
    <div id="container"></div>
</body>

<script src="r69/three.js"></script>
<script src="r69/OrbitControls.js"></script>
<script src="r69/ImprovedNoise.js"></script>
<script src="r69/Detector.js"></script>
<script src="r69/stats.min.js"></script>
<script src="utils.js"></script>
<script src="CloudGeometry.js"></script>
<script src="Clouds.js"></script>
<script src="math.js"></script>
<script src="Island.js"></script>

<script src="shaders/AdditiveBlendShader.js"></script>
<script src="shaders/CopyShader.js"></script>
<script src="shaders/HorizontalBlurShader.js"></script>
<script src="shaders/VerticalBlurShader.js"></script>
<script src="shaders/DotScreenShader.js"></script>
<script src="shaders/RGBShiftShader.js"></script>

<script src="r69/postprocessing/EffectComposer.js"></script>
<script src="r69/postprocessing/RenderPass.js"></script>
<script src="r69/postprocessing/MaskPass.js"></script>
<script src="r69/postprocessing/ShaderPass.js"></script> 
<script type="text/javascript" id="mainCode">

 var _renderer, _composer, cComposer, mComposer,
    _scene,
    _mountainScene, _mountainLight,
    _camera, _camera2,
    _controls, _stats;
 var clock = new THREE.Clock();
if ( ! Detector.webgl ) {

  Detector.addGetWebGLMessage();
  document.getElementById( 'container' ).innerHTML = "";

}
else {
  // STATS
  _stats = new Stats();
  _stats.domElement.style.position = 'absolute';
  _stats.domElement.style.bottom = '0px';
  _stats.domElement.style.zIndex = 100;
  document.body.appendChild( _stats.domElement );    

  initScenes();
  window.addEventListener( 'load', function() {
    var img = new Image();
    img.onload = function () {
        loadShaderFiles(['shaders/noise-fs.js','shaders/noise-vs.js'], function (shaderText) {

          var cloudMaterial = getCloudMaterial(shaderText[0],shaderText[1]);
          for (var igeo = 0; igeo < 8; igeo++) {
            var cloudGeo1 = createCloud();
            addClouds(_scene, cloudGeo1, cloudMaterial);
          }
          drawHeightMap(img);
          blur();
          render();
        }, function (url) {
            alert('Failed to download "' + url + '"');
        }
      );
    };
    img.src = 'HeightMap.png';
  });
}
function initScenes() {
  var container = document.getElementById( "container" );
  _renderer = new THREE.WebGLRenderer();
  _renderer.setSize( window.innerWidth, window.innerHeight );
  // _renderer.setClearColor( 0xbfd1ff );
  container.appendChild( _renderer.domElement );

  _scene = new THREE.Scene();
  _mountainScene = new THREE.Scene();

  _camera = new THREE.PerspectiveCamera( 
      30, 
      window.innerWidth / window.innerHeight, 
      1, 
      10000 );
  // _camera.position.x = 246;  _camera.position.y = 347;  _camera.position.z = 106;
  // _camera.position.x = 76;  _camera.position.y = 88;  _camera.position.z = -421;
  _camera.position.x = 232;  _camera.position.y = 168;  _camera.position.z = 31;
  _camera.target = new THREE.Vector3( 0, 0, 0 );

  _camera2 = new THREE.PerspectiveCamera( 
      30, 
      window.innerWidth / window.innerHeight, 
      1, 
      10000 );
  _camera2.position.x = _camera.position.x;
  _camera2.position.y = _camera.position.y;
  _camera2.position.z = _camera.position.z;
  _camera2.target = new THREE.Vector3( 0, 0, 0 );

  _scene.add( _camera );
  _mountainScene.add( _camera2 );
  _controls = new THREE.OrbitControls( _camera, container.domElement );
  _controls2 = new THREE.OrbitControls( _camera2, container.domElement );

  var spotLight = new THREE.SpotLight( 0xffffff ); 
  spotLight.position.set( -400, 400, -1200 ); 
  spotLight.shadowCameraNear = 100; spotLight.shadowCameraFar = 4000; spotLight.shadowCameraFov = 30; 
  _scene.add(spotLight);

  var spotLight2 = new THREE.SpotLight( 0xffffff ); 
  spotLight2.position.x = spotLight.position.x;
  spotLight2.position.y = spotLight.position.y;
  spotLight2.position.z = spotLight.position.z;

  spotLight2.shadowCameraNear = 100; spotLight.shadowCameraFar = 4000; spotLight.shadowCameraFov = 30; 
  _mountainScene.add(spotLight2);
  _mountainLight = spotLight2;

}
function blur() {
  var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter,
                     format: THREE.RGBFormat, stencilBuffer: false };
  var renderTargetM = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, parameters );
  var renderTargetC = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, parameters );

  cComposer = new THREE.EffectComposer( _renderer, renderTargetC );
  cComposer.addPass( new THREE.RenderPass( _scene, _camera ) );

  horizontalBlurPass = new THREE.ShaderPass( THREE.HorizontalBlurShader );
  cComposer.addPass( horizontalBlurPass );

  verticalBlurPass = new THREE.ShaderPass( THREE.VerticalBlurShader );
  // verticalBlurPass.renderToScreen = true;
  cComposer.addPass( verticalBlurPass );
  var effect1 = new THREE.ShaderPass( THREE.CopyShader );
  effect1.renderToScreen = true;
  cComposer.addPass( effect1 );

  mComposer = new THREE.EffectComposer( _renderer, renderTargetM );
  var mRenderPass =  new THREE.RenderPass( _mountainScene, _camera2 );
  mComposer.addPass( mRenderPass );
  var effect = new THREE.ShaderPass( THREE.CopyShader );
  effect.renderToScreen = true;
  mComposer.addPass( effect );


  blendPass = new THREE.ShaderPass( THREE.AdditiveBlendShader );
  blendPass.uniforms[ 'tBase' ].value = mComposer.renderTarget2;
  blendPass.uniforms[ 'tAdd' ].value = cComposer.renderTarget2;
  blendPass.uniforms[ 'amount' ].value = 1.;
  _composer = new THREE.EffectComposer( _renderer );
  _composer.addPass( blendPass );
  blendPass.renderToScreen = true;

}
function drawHeightMap(img, light) {
  var worldWidth = 512, worldDepth = 512,
      data = getHeightData(img, worldWidth, worldDepth);

  var geometry = 
    new THREE.PlaneBufferGeometry( 325, 325, worldWidth - 1, worldDepth - 1 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  var texture = new THREE.Texture( 
    generateTexture( data, worldWidth, worldDepth, _mountainLight ), new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping );
  texture.needsUpdate = true;
  var material = new THREE.MeshLambertMaterial( { map: texture } );

  mesh = new THREE.Mesh( geometry, material );
  var vertices = geometry.attributes.position.array;

  for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
      vertices[ j + 1 ] = .08*data[ i ] - 25;
  }
  _mountainScene.add(mesh);
}
function initClouds(noisefs,noisevs) { 
          
    var texture = THREE.ImageUtils.loadTexture("cloud10.png");
    material = new THREE.ShaderMaterial( {
    uniforms: //THREE.UniformsUtils.merge([ // see: https://csantosbh.wordpress.com/2014/01/09/custom-shaders-with-three-js-uniforms-textures-and-lighting/ 
            {
              "map": { type: "t", value: texture },
              ambientLightColor : { type: "fv", value: [] },
              directionalLightDirection : { type: "fv", value: [] },
              directionalLightColor : { type: "fv", value: [] },
              hemisphereLightDirection : { type: "fv", value: [] },
              hemisphereLightSkyColor : { type: "fv", value: [] },
              hemisphereLightGroundColor : { type: "fv", value: [] },
              pointLightColor : { type: "fv", value: [] },
              pointLightPosition : { type: "fv", value: [] },
              pointLightDistance : { type: "fv1", value: [] },
              spotLightColor : { type: "fv", value: [] },
              spotLightPosition : { type: "fv", value: [] },
              spotLightDirection : { type: "fv", value: [] },
              spotLightDistance : { type: "fv1", value: [] },
              spotLightAngleCos : { type: "fv1", value: [] },
              spotLightExponent : { type: "fv1", value: [] }
            },
    // ]),
        vertexShader: noisevs,
        fragmentShader: noisefs,
        transparent: true,
        lights: true,
    } );
     
    var cloudGeo = createCloud();
    var mesh = new THREE.Mesh( 
        //new THREE.SphereGeometry(10, 70, 70),
       createCloud(),
        //new THREE.IcosahedronGeometry( 20, 4 ), 
      material
      //new THREE.MeshNormalMaterial()

    );
    // cloudGeo.scale.x = .7;
    // cloudGeo.scale.z = .7;
    // cloudGeo.scale.y = .5;
    _scene.add( mesh );
 
} 
function render() {
  moveClouds();
   _controls.update( clock.getDelta() );
    _controls2.update( clock.getDelta() );
    mComposer.render();
    cComposer.render();
    _composer.render();
    _stats.update();
    requestAnimationFrame( render );
    //rotateCameraY(.02);
}

</script>
 
</html>