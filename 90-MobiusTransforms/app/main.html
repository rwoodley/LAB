<!DOCTYPE html>
<html lang="en">
	<head>
        <style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
			.statusText {
				height:30px;
				width:300px;
				color: #00ff00;
				padding: 5px;
				background-color: black;
			}
            .divpselector { 
            	border: 2px solid; 
            	border-color: #6495ED; margin: 5px; padding: 5px; color: #000000; 
            	background-color: rgba(88,88,255,.5);
            	width: 40px;
            	height: 40px;
            	display: inline-block;
            	vertical-align: middle;
            }
            .pselector { 
            	border: 2px solid; 
            	border-color: #6495ED; margin: 5px; padding: 5px; color: #000000; 
            	background-color: rgba(88,88,255,.5);
            	width: 40px;
            	display: inline-block;
            	vertical-align: middle;
            }
            .pselectorText > span {
            	font-size: 14pt;
			    vertical-align: top;
            }
            .mainDashboard {
				/*position: relative;*/
            }
		</style>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        
          ga('create', 'UA-41066114-1', 'rwoodley.org');
          ga('send', 'pageview');
        
        </script>
		<script src="r73/three.js"></script>
        <script src="r73/OrbitControls.js"></script>
		<script src="r73/Detector.js"></script>
 		<script src="r73/stats.min.js"></script>
		<script src="lib/jquery-3.1.0.min.js"></script>
		<script src="utils.js"></script>
		<script id="vs" type="x-shader/x-vertex">
			varying vec2 vUv; 
			void main()
			{
			    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
			    gl_Position = projectionMatrix * mvPosition;
			    vUv = uv;
			}
		</script>

		<script id="fs" type="x-shader/x-fragment">
			#define PI 3.1415926535897932384626433832795
			uniform sampler2D iChannel0;
			varying vec2 vUv;  
			#define cx_product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
			#define cx_conjugate(a) vec2(a.x,-a.y)
			#define cx_divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
			// emulate OpenGL 4.5's mix(,,bool)
			float mix(float x, float y, bool a) {
			  return a ? y : x;
			}

			// proposed solution from 
			// http://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle
			// swaps params when |x| <= |y|
			float atan2(in float y, in float x) {
				// float res = atan(y,x);
				// return res;
			    bool s = (abs(x) >= abs(y));
			    // bool s = abs(y) > 1./32.;
			    float res = mix(PI/2.0 - atan(x,y), atan(y,x), s);
			    // float res = mix(0.0,atan(y,x), s);
			    return res;
			}
			// https://github.com/julesb/glsl-util/blob/master/complexvisual.glsl
			vec2 cx_sqrt(vec2 a) {
			    float r = sqrt(a.x*a.x+a.y*a.y);
			    float rpart = sqrt(0.5*(r+a.x));
			    float ipart = sqrt(0.5*(r-a.x));
			    if (a.y < 0.0) ipart = -ipart;
			    return vec2(rpart,ipart);
			}
			vec2 cx_log(vec2 a) {
			    float rpart = sqrt((a.x*a.x)+(a.y*a.y));
			    float ipart = atan2(a.y,a.x);
			    if (ipart > PI) ipart=ipart-(2.0*PI);
			    return vec2(log(rpart),ipart);
			}
			vec2 cx_exp(vec2 z) {
				return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));
			}


			uniform float iGlobalTime;
			uniform float zoomFactor;
			uniform float e1x;
			uniform float e1y;
			uniform float e2x;
			uniform float e2y;
			uniform int effectsOnOff;		// 0=nothing,1=rotate,2=zoom
			uniform bool showFixedPoints;
			vec2 one = vec2(1.0, 0.0);
			vec2 zero = vec2(0.0, 0.0);

			vec2 applyMobiusTransformation(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {
				vec2 top = cx_product(z,a)+b;
				vec2 bottom = cx_product(z,c)+d;
				return cx_divide(top,bottom);
			}
			vec2 applyInverseMobiusTransform(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {
				// inverse is (dz-b)/(-cz+a).
				return applyMobiusTransformation(z,d,-b,-c,a);
			}
			vec2 transformForFixedPoints(in vec2 z, in vec2 e1, in vec2 e2) {
				return applyMobiusTransformation(z,one,-e1,one,-e2);
			}
			vec2 inverseTransformForFixedPoints(in vec2 z, in vec2 e1, in vec2 e2) {
				// inverse is (dz-b)/(-cz+a). a and c are 1.
				return applyInverseMobiusTransform(z,one,-e1,one,-e2);
			}
			vec2 applyRotation(in vec2 z, in float radians) {
				// vec2 exp = cx_exp(vec2(0.,radians));
				vec2 exp = vec2(cos(radians), sin(radians));
				vec2 ans = cx_product(z, exp);
				return ans;
			}
			vec2 zoom(in vec2 z, in float factor) {
				vec2 ans = cx_product(vec2(factor,0),z);
				return ans;
			}
			vec2 weirdExpTransform(vec2 z) {
				// vec2 n = one + z;
				// vec2 d = one - z;
				// vec2 f = cx_divide(n,d);
				// vec2 res = -1. * cx_exp(-4.*f);
				vec2 res = cx_exp(z);
				return res;
			}
			vec2 anotherTransform(vec2 z) {
				vec2 i = vec2(0., 1.);
				vec2 n = z-i;
				vec2 d = z+i;
				vec2 f = cx_divide(n,d);
				vec2 res = 1. * cx_exp(4.*f);
				return res;
				// vec2 i = vec2(1., 0.);
				// vec2 n = 1.+z;
				// vec2 d = 1.-z;
				// vec2 f = cx_divide(n,d);
				// return f;
			}
			vec3 complexToCartesian(vec2 c) {
				float denom = 1.0 + c.x*c.x + c.y*c.y;
				float x = 2.*c.x/denom;
				float y = 2.*c.y/denom;
				float z = (c.x*c.x + c.y*c.y - 1.0)/denom;
				return vec3(x,y,z);
			}
			void main() {
				 float theta;
				 float phi;
				 float x;
				 float y;
				 float z;

				vec2 uv = vUv;
				uv.x = clamp(uv.x,0.001,.999);

				// ---------
			    // convert from uv to polar coords
			    vec2 tempuv = uv;
				// vec2 tempuv = uv * 0.9999 + 0.00005;
				theta = (1.0-tempuv[1]) * PI;
				phi = PI * 2.0 * tempuv[0];

				// convert polar to cartesian. Theta is polar, phi is azimuth.
				x = sin(theta)*cos(phi);
				y = sin(theta)*sin(phi);
				z = cos(theta);

				// x,y,z are on the unit sphere.
				// if we pretend that sphere is a riemann sphere, then we
				// can get the corresponding complex point, a.
				// http://math.stackexchange.com/questions/1219406/how-do-i-convert-a-complex-number-to-a-point-on-the-riemann-sphere

				vec2 a = vec2(x/(1.0-z), y/(1.0-z));

				vec2 result;
				if (e1x == e2x && e1y == e2y) {
					result = a;	// if no fixed points, do nothing.
				}
				else {
					vec2 e1 = vec2(e1x,e1y);
					vec2 e2 = vec2(e2x,e2y);
					if (showFixedPoints) {
						vec3 e1InCartesian = complexToCartesian(e1);
						vec3 e2InCartesian = complexToCartesian(e2);
						vec3 aInCartesian = complexToCartesian(a);

						if (distance(aInCartesian, e1InCartesian) < .05) {
							gl_FragColor = vec4(1.,0.,0.,1.);
							return;
						}
						if (distance(aInCartesian, e2InCartesian) < .05) {
							gl_FragColor = vec4(0.,1.,0.,1.);
							return;
						}						
					}

					if (effectsOnOff == 0) {
						result = a;
					}
					else {
						vec2 b = transformForFixedPoints(a, e1, e2);
						vec2 c;
						vec2 b1 = applyRotation(b,iGlobalTime/10.);
						c = zoom(b1, zoomFactor);
						result = inverseTransformForFixedPoints(c, e1, e2);
						// result = cx_product(result, result);
						//result = anotherTransform(result);
					}
				}

				// // // // now c back to sphere.
				float denom = 1.0 + result.x*result.x + result.y *result.y;
				x = 2.0 * result.x/denom;
				y = 2.0 * result.y/denom;
				z = (result.x*result.x + result.y*result.y - 1.0)/denom;

				// convert to polar
				// problem: the phi above is [0,2*PI]. this phi is [0,2*PI)
				phi = atan2(y, x);
				if (phi <= 0.0) {
					phi = phi + PI*2.0;	
				}
				if (phi >= (2.0 * PI)) {	// allow 2PI since we gen uv over [0,1]
					phi = phi - 2.0 * PI;
				}
				theta = acos(z);

				// now get uv in new chart.
				float newv = 1.0 - theta/PI;
				float newu = phi/(2.0 * PI);
				vec2 newuv = vec2(newu, newv);
			    vec4 tex1 = texture2D( iChannel0,  newuv);
				gl_FragColor = tex1;
			}

		</script>
		<script>
			var _container;
			var _camera, _controls, _scene, _renderer, _uniforms, _stats, _axes;
			var myMesh, _rotateSpeed = Math.PI/1024, _controlPanelVisible = true;

			if ( ! Detector.webgl ) {
				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";
			}

			var clock = new THREE.Clock();
			function toggleControlPanel() {
		    	_controlPanelVisible = !_controlPanelVisible;
		    	if (_controlPanelVisible) {
					$('.controlPanel').hide();
					_axes.visible = false;
				}
	    		else {
					$('.controlPanel').show();
					_axes.visible = true;
				}
			}
			function init() {
				document.body.onkeyup = function(e){
				    if(e.keyCode == 32)
				    	toggleControlPanel();
				}
                _container = document.getElementById( 'container' );

                _camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

                _scene = new THREE.Scene();
                _controls = new THREE.OrbitControls( _camera, _container.domElement );
                _renderer =  new THREE.WebGLRenderer({ antialias: true } );

                _camera.position.x = -3; _camera.position.y = 0.0; _camera.position.z = 0;
                _axes = new THREE.AxisHelper( 5000 );
                _scene.add(_axes);
				toggleControlPanel();
                var segment = 256.;
                var sphereRadius = 1;
				var planeGeometry = new THREE.PlaneBufferGeometry( sphereRadius*2, sphereRadius*2, segment, segment );

                var skyGeometry = new THREE.SphereGeometry(sphereRadius,segment,segment);

				var newMaterial = new THREE.MeshNormalMaterial();
                _skyBox = new THREE.Mesh( skyGeometry, newMaterial);
                _scene.add( _skyBox );

                _plane = new THREE.Mesh( planeGeometry, newMaterial );
                _plane.rotateY(Math.PI/2);
                _scene.add( _plane );
                sphereOnlyView();

                _renderer.setSize( window.innerWidth, window.innerHeight );

                document.getElementById( 'container' ).innerHTML = "";
                _container.appendChild( _renderer.domElement );
				_uniforms = {
				    iGlobalTime:    { type: 'f', value: 0.0 },
				    effectsOnOff: { type: 'i', value: 0 },
				    showFixedPoints: { type: 'i', value: 1 },
				    zoomFactor: { type: 'f', value: 1.0 },
				    e1x: { type: 'f', value: 0. },
				    e1y: { type: 'f', value: 0. },
				    e2x: { type: 'f', value: 0. },
				    e2y: { type: 'f', value: 0. },
				};
				_stats = new Stats();
				_stats.domElement.style.position = 'absolute';
				_stats.domElement.style.bottom = '0px';
				_stats.domElement.style.zIndex = 100;
				document.body.appendChild( _stats.domElement );    
                animate();
                updateSkyDome('uv');
			}

			function animate() {
				requestAnimationFrame( animate );
				_controls.update( clock.getDelta() );
				_renderer.render( _scene, _camera );
                _camera.lookAt(new THREE.Vector3(0,0,0));
                // _skyBox.rotateY(0.002);
                // _plane.rotateZ(0.002);
                _uniforms.iGlobalTime.value = _uniforms.iGlobalTime.value  + .1*_rotateDirection;
                //console.log(_uniforms.iGlobalTime.value + "," + _uniforms.zoomFactor.value)
                updateVariousNumbersForCamera();
                _stats.update();
			}
            function updateSkyDome(pid) {
                var pathToTexture = 'textures/' + pid + '.jpg';
				(new THREE.TextureLoader()).load(pathToTexture, function ( texture ) {
					_uniforms.iChannel0 =  { type: 't', value: texture }; 
					texture.minFilter = THREE.LinearFilter;	// eliminates aliasing when tiling textures.
					newMaterial = new THREE.ShaderMaterial( {
						uniforms: _uniforms,
						vertexShader: document.getElementById( 'vs' ).textContent,
						fragmentShader: document.getElementById( 'fs' ).textContent,
						side: THREE.DoubleSide,
						// wireframe: true
					} );

					_skyBox.material = newMaterial;
					_plane.material = newMaterial; 

				});
            }
            function toggleView() {
            	if (!_plane.visible) {
            		planeOnlyView();
            	}
            	else {
            		sphereOnlyView();
            	}
            }
            function sphereOnlyView() {
            	_skyBox.visible = true;
                _skyBox.geometry.radius = 10;
                _skyBox.position.set(0,0,0);
        		_plane.visible = false;
        		_plane.scale.set(10,10,10);
        		_skyBox.scale.set(10,10,10);
            }
            function planeOnlyView() {
            	_skyBox.visible = false;
                _plane.position.set(0,0,0);
        		_plane.visible = true;
        		_plane.scale.set(1,1,1);
            }
            function sphereAndPlaneView() {
	                _skyBox.geometry.radius = 1;
	                _skyBox.position.set(0,0,0);
	                _plane.position.set(0,0,2);
            		_plane.visible = true;
            		_plane.scale.set(1,1,1);
            		_skyBox.scale.set(1,1,1);
            }
            var _rotateDirection = 0;
            function rotate(direction) {
				setFixedPointsIfUndefined();
            	_uniforms.effectsOnOff.value = 1;
            	if (direction == 0) {
            		_rotateDirection = 0;
            	}
            	else {
	            	_rotateDirection += direction;
            	}
            }
            function rotationOff() {
            		_rotateDirection = 0;
	            	_uniforms.iGlobalTime.value = 0;
            }
            var _currentZoom = 1;
            function zoom(factor) {
				setFixedPointsIfUndefined();
            	_uniforms.effectsOnOff.value = 1;
            	_currentZoom *= factor;
            	_uniforms.zoomFactor.value = _currentZoom;
            	console.log(_currentZoom);
            }
            function antipode(inx,iny) {
            	// -(1/conj(x,y))
            	var x = inx;
            	var y = -iny; // conjugate
            	var denom = x*x + y*y;
            	return {
            		x: -x/denom,
            		y: y/denom
            	}
            }
            var _point1Defined = false;
            var _point2Defined = false;
            function setFixedPointsIfUndefined() {
            	if (!_point1Defined && !_point2Defined) {
            		setFixedPoint(1);
            	}
            }
            function setFixedPoint(pointNumber) {
            	_uniforms.effectsOnOff.value = 1;
            	var x = _cameraLookAtComplexX;
            	var y = _cameraLookAtComplexY;
            	if (pointNumber == 1) {
	            	_uniforms.e1x.value = x;
	            	_uniforms.e1y.value = y;
	            	_point1Defined = true;
	            	if (!_point2Defined) {
		            	var ant = antipode(x,y);
		            	_uniforms.e2x.value = ant.x;
		            	_uniforms.e2y.value = ant.y;	            		
	            	}
	            }
	            else {
	            	_uniforms.e2x.value = x;
	            	_uniforms.e2y.value = y;	            	
	            	_point2Defined = true;
	            	if (!_point1Defined) {
		            	var ant = antipode(x,y);
		            	_uniforms.e1x.value = ant.x;
		            	_uniforms.e1y.value = ant.y;	            		
	            	}
	            }
            	console.log("P1 = " + _uniforms.e1x.value + "," + _uniforms.e1y.value);
            	console.log("P2 = " + _uniforms.e2x.value+ "," + _uniforms.e2x.value);
            }
            var _unitVector;
            var _fixedPointX, _fixedPointY;
            function updateVariousNumbersForCamera() {
            	_unitVector = (new THREE.Vector3()).copy(_camera.position).normalize();
				// in three.js y is up. we want z to be up.
				// flip the signs on x and z because we're inside the sphere. i think?
				var x = -_unitVector.x;
				var y = _unitVector.z;	// assign z to y.
				var z = -_unitVector.y;	// assign y to z.

            	// convert to point on complex plane
            	_cameraLookAtComplexX = - x / (1.0 - z);
            	_cameraLookAtComplexY = - y / (1.0 - z);

            	try {
	                document.getElementById('unitVectorText').innerHTML = 
	                "<nobr>Unit Vec: (" + 
	                	_unitVector.x.toFixed(1) + "," + 
	                	_unitVector.z.toFixed(1) + "," + 
	                	_unitVector.y.toFixed(1) + ") len: " 
						+ _unitVector.length().toFixed(1) + "</nobr>" ;   

	                document.getElementById('complexPointText').innerHTML = "Looking at " + 
	                	_cameraLookAtComplexX.toFixed(2) + " + " + 
	                	_cameraLookAtComplexY.toFixed(2) + "i";

	                _textElement = document.getElementById('cameraText');
	                _textElement.innerHTML = "<nobr>Camera: (" + _camera.position.x.toFixed(1) 
	                	+ "," + _camera.position.y.toFixed(1) + ","  
	                	+ _camera.position.z.toFixed(1) + ") len: " 
						+ _camera.position.length().toFixed(1) + "</nobr>" ;
				}
				catch (x) {}
            }
            function flipCamera() {
            	_camera.position.x = - _camera.position.x;
            	_camera.position.y = - _camera.position.y;
            	_camera.position.z = - _camera.position.z;
            }
            function reset() {
            	_currentZoom = 1.0;
            	_uniforms.zoomFactor.value = _currentZoom;
            	_rotateDirection = 0;
            	_uniforms.iGlobalTime.value = 0;
            	_point1Defined = false;
            	_point2Defined = false;
            	_uniforms.effectsOnOff = 0;
            	_uniforms.e1x.value = _uniforms.e1y.value = _uniforms.e2x.value = _uniforms.e2y.value = 0;
            }
            function toggleShowHideFixedPoints() {
            	_uniforms.showFixedPoints.value = _uniforms.showFixedPoints.value == 0 ? 1 : 0;
            }
</script>
	</head>
	<body>
		<div id="container"><br /><br /><br /><br /><br />Generating...</div>
        <div style="position: fixed; top: 3%; width:95%; ">
            <div style="float: left; "  class="controlPanel">
                <!-- for pinterest -->
                <img src='snap.png' width='1px' height='1px' />
                <!-- end of pinterest hack -->
                &nbsp;&nbsp;
                <span onclick='updateSkyDome(1)' class='pselector'>1</span>
                <span onclick='updateSkyDome(2)' class='pselector'>2</span>
                <span onclick='updateSkyDome(3)' class='pselector'>3</span>
                <span onclick='updateSkyDome(4)' class='pselector'>4</span>
                <span onclick='updateSkyDome(5)' class='pselector'>5</span>
                <span onclick='updateSkyDome("mich")' class='pselector'>mich</span>
                <span onclick='updateSkyDome("HLIE1245")' class='pselector'>New</span>
                <span onclick='updateSkyDome("c1")' class='pselector'>Chi</span>
                <span onclick='updateSkyDome("louis")' class='pselector'>Boy</span>
                <span onclick='updateSkyDome("uv")' class='pselector'>uv</span>
            </div>
            <div style="float: right; " class="controlPanel mainDashboard">
                 <!-- <div id='cameraText' class="statusText"></div> -->
                 <!-- <div id='unitVectorText' class="statusText"></div> -->
                 <!-- <div id='complexPointText' class="statusText"></div> -->
                <img src='icons/rotateLeft.png' onclick='rotate(-1)' title="Rotate Left" class='pselector'></img>
                <img src='icons/rotateRight.png' onclick='rotate(1)'  title="Rotate Right" class='pselector'></img>
                <img src='icons/pause.png' onclick='rotate(0)'  title="Stop Rotation" class='pselector'></img>
                <img src='icons/stop.png' onclick='rotationOff()'  title="No Rotation" class='pselector'></img>
<!--                 <div onclick='rotate(1)' class='pselector'>Rotate Right</div>
                <div onclick='rotate(0)' class='pselector'>Stop Rotating</div>
                <div onclick='rotationOff()' class='pselector'>No Rotation</div>
                <div onclick='zoom(.5)' class='pselector'>Zoom In</div>
                <div onclick='zoom(2)' class='pselector'>Zoom Out</div>
                <div onclick='zoom(-1)' class='pselector'>Zoom Negative</div>
 -->
                <img src='icons/zoomIn.png' onclick='zoom(.5)'  title="Zoom In" class='pselector'></img>
                <img src='icons/zoomOut.png' onclick='zoom(2)'  title="Zoom Out" class='pselector'></img>
                <img src='icons/cancel.png' onclick='zoom(2)'  title="Zoom Out" class='pselector'></img>
                <span onclick='setFixedPoint(1)' class='divpselector'>
<nobr><img src='icons/epsilon.png' onclick='toggleShowHideFixedPoints()'  title="Set Fixed Point 1" width="30px;"></img><span class='pselectorText'><span >+</span></nobr>
            </span>
            	</span>
                <div onclick='setFixedPoint(2)' class='divpselector' >
<nobr><img src='icons/epsilon.png' onclick='toggleShowHideFixedPoints()'  title="Set Fixed Point 2" width="30px;"></img><span class='pselectorText'><span >-</span></nobr>
            </span>
            	</div>

                <img src='icons/debug.png' onclick='toggleShowHideFixedPoints()'  title="Show Fixed Points" class='pselector'></img>
                <img src='icons/toggle.png' onclick='toggleView()'  title="Toggle View" class='pselector'></img>

                <img src='icons/flipCamera.png' onclick='flipCamera()'  title="Flip Camera" class='pselector'></img>

                <img src='icons/reset.png' onclick='reset()'  title="Reset" class='pselector'></img>
            </div>
        </div>
        <script>
		init();
        </script>
	</body>
</html>
