<!DOCTYPE html>
<html lang="en">
	<body>
		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<script src="r73/three.js"></script>
        <script src="r73/OrbitControls.js"></script>
		<script src="r73/Detector.js"></script>
        <script src="utils.js"></script>
        <style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
		<script id="vs" type="x-shader/x-vertex">
			#define PI 3.1415926535897932384626433832795
			varying vec2 vUv; 
			#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
			#define conjugate(a) vec2(a.x,-a.y)
			#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))
			uniform float iGlobalTime;
				 varying float theta;
				 varying float phi;
				 varying float x;
				 varying float y;
				 varying float z;

			// emulate OpenGL 4.5's mix(,,bool)
			float mix(float x, float y, bool a) {
			  return a ? y : x;
			}

			// proposed solution from 
			// http://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle
			// swaps params when |x| <= |y|
			float atan2(in float y, in float x) {
			    bool s = (abs(x) >= abs(y));
			    float res = mix(PI/2.0 - atan(x,y), atan(y,x), s);
			    return res;
			}
			vec2 applyMobiusTransformation(in vec2 z) {
				vec2 a = vec2(1.0, 1.0);
				vec2 b = vec2(0.0, 1.0);
				vec2 top = product(z,a)+b;
				vec2 c = vec2(1.0, 0.0);
				vec2 d = vec2(0.0, 1.0);
				vec2 bottom = product(z,c)+d;
				return divide(top,bottom);
				// return bottom;
			}
			void main()
			{

			    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
			    gl_Position = projectionMatrix * mvPosition;

			    // convert from uv to polar coords
			    float tempuv1 = max(0.0001,min(.9999,uv[1]));
				theta = (1.0-tempuv1) * PI;
			    float tempuv0 = max(0.0001,min(.9999,uv[0]));
				phi = PI * 2.0 * tempuv0;

				// convert polar to cartesian. Theta is polar, phi is azimuth.
				x = sin(theta)*cos(phi);
				y = sin(theta)*sin(phi);
				z = cos(theta);

				// convert riemann sphere to complex plane (X+Yi)
				// http://math.stackexchange.com/questions/1219406/how-do-i-convert-a-complex-number-to-a-point-on-the-riemann-sphere
				vec2 a = vec2(x/(1.0-z), y/(1.0-z));
				vec2 c = applyMobiusTransformation(a);
				// vec2 c = a;

				// // // // now c back to sphere.
				float denom = 1.0 + c.x*c.x + c.y *c.y;
				x = 2.0 * c.x/denom;
				y = 2.0 * c.y/denom;
				z = (c.x*c.x + c.y*c.y - 1.0)/denom;

				// convert to polar
				phi = atan2(y,x);
				if (phi < 0.0) {
					phi = phi + PI*2.0;	
				}
				if (phi > (2.0 * PI)) {
					phi = phi - 2.0 * PI;
				}
				theta = acos(z);

				// now get uv in new chart.
				float newv = 1.0 - theta/PI;
				float newu = phi/(2.0 * PI);

				vUv = vec2(newu, newv);

			}
		</script>

		<script id="fs" type="x-shader/x-fragment">
			#define PI 3.1415926535897932384626433832795


			uniform sampler2D iChannel0;
			
			varying vec2 vUv;  
            varying vec4 vColor;
			varying float theta;
			varying float phi;
			varying float x;
			varying float y;
			varying float z;

			void main() {
				vec2 uv = vUv;
			    vec4 tex1 = texture2D( iChannel0,  uv);
				gl_FragColor = tex1;
				// gl_FragColor = vec4(1.0-uv[0],0,tex1[2],1);
			}

		</script>
		<script>
			var _container;
			var _camera, _controls, _scene, _renderer, _uniforms;
			var myMesh, _rotateSpeed = Math.PI/1024;

			if ( ! Detector.webgl ) {
				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";
			}

			var clock = new THREE.Clock();
			init();

			function init() {
                _container = document.getElementById( 'container' );

                _camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

                _scene = new THREE.Scene();
                _controls = new THREE.OrbitControls( _camera, _container.domElement );
                _renderer =  new THREE.WebGLRenderer();

                _camera.position.x = 1.5; _camera.position.y = 2.0; _camera.position.z = 0;
                var axes = new THREE.AxisHelper( 5000 );
                _scene.add(axes);

				var planeGeometry = new THREE.PlaneBufferGeometry( 2, 2, 128, 128 );

                var skyGeometry = new THREE.SphereGeometry(1,128,128);
                var texture;
                var pathToTexture = 'textures/1.jpg';
                texture = THREE.ImageUtils.loadTexture(pathToTexture);
            
				_uniforms = {
				    iGlobalTime:    { type: 'f', value: 0.1 },
				    iChannel0:  { type: 't', value: THREE.ImageUtils.loadTexture( 'textures/uv.jpg') },
				};
				newMaterial = new THREE.ShaderMaterial( {
					uniforms: _uniforms,
					vertexShader: document.getElementById( 'vs' ).textContent,
					fragmentShader: document.getElementById( 'fs' ).textContent,
					side: THREE.DoubleSide 
				} );
                // var skyMaterial = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide });
                _skyBox = new THREE.Mesh( skyGeometry, newMaterial );
                _skyBox.position.set(0,0,1);
                _skyBox.scale.set(-1,1,1);
                _scene.add( _skyBox );

                _plane = new THREE.Mesh( planeGeometry, newMaterial );
                _plane.position.set(0,0,-1);
                _plane.rotateX(-Math.PI/2);
                _plane.rotateZ(Math.PI/2);
                _scene.add( _plane );

                _renderer.setSize( window.innerWidth, window.innerHeight );

                document.getElementById( 'container' ).innerHTML = "";
                _container.appendChild( _renderer.domElement );
                animate();
			}

			function animate() {
				requestAnimationFrame( animate );
				_controls.update( clock.getDelta() );
				_renderer.render( _scene, _camera );
                _camera.lookAt(new THREE.Vector3(0,0,0));
                //_skyBox.rotateY(0.002);
                _uniforms.iGlobalTime.value = _uniforms.iGlobalTime.value  + .1;
			}
</script>
	</body>
</html>
